# Team 5 - Ride Replay Kit
## Team Members: Benjamin Ebel, Caleb Rozenboom, Caleb Turney, Jayden Marcom, Jesse Brewster, Utsav Singha

## Experimentation

### GUI Subsystem - Benjamin Ebel

| Item | Testing Method | Results | Was The Constraint Fulfilled | Why Was The Constraint Not Fulfilled (if applicable) |
|------|----------------|---------|------------------------------|------------------------------------------------------|
|Overexertion Reminder|Using the time library in Python we can see how long a piece of code or function has been running. Using this a variable was created for when detecting how long the user has been riding the exercise bike and at the 2-hour mark a pop-up window appears pausing the trail and alerting the user that they have been riding for over 2 hours and asks them to acknowledge that if they continue to ride it can possibly cause damage to their muscles. After the trail has been started a time variable starts counting up in seconds and once it gets to 7200 seconds the pop-up window appears alerting the user and won’t continue until they press ok on the window. |By setting the time variable to 7140 seconds and then starting the timing module, we allowed the system to run for a minute. The pop-up window then appeared alerting the user of the risk of overexertion. Additionally, it will not close or resume the trail until they acknowledge the pop-up.|Yes||
|Loading Screen/Interaction Latency/User Interrupt|Using the time library in Python we can see how long a piece of code or function has been running. I set a start time variable to start at the beginning of a function call and an end time variable to store the value of the time at the end of the function call. Once this had been done I took the end time minus the start time to get the result of how long the function took to run. If one of these tests takes longer than 300ms to run a loading screen was put in place to alert the user that their input has been seen and will be handled soon.|Almost every function in the GUI had less than 300ms execution time except for loading the video. I tested the play video function with a short video of around 5 minutes and a 4-hour-long trail ride and both of these tests resulted in a latency of longer than a second. Since this is longer than the allowed latency of 300ms I put in a loading screen to ensure the user was aware their input had been seen. These test latencies can be seen under the Latency Graphs header below.|Yes||
|Color Blindness Sensitivity|I will take a picture of the GUI using an iPhone camera. Then I will edit a black-and-white filter over it using the built-in filters on the iPhone. This will ensure that everything on the GUI can still be read by users with the harshest kind of color blindness which is total color blindness.|Using the photos below under the Color Blind Photos Test header, it can be seen that the UI would still be visible to someone who had complete color blindness.|Yes||
|Menu Interaction to Desired State|The goal of this constraint was to ensure the User does not get confused or frustrated while navigating through the menu. To eliminate this the GUI was simplified to have all the menu options be presented to the user on one page. This ensures that the user does not have to go through multiple different windows to achieve the desired result. To test this all menu interactions will be interacted with and placed into a state diagram to display all the possible menu interactions and their functions.|Since all the buttons on the GUI are only set to do a specific task all of the buttons achieve their task and then return to the main menu waiting for the next user interaction. All the menu interactions were plotted in the state diagram in the State Diagram header below.|Yes||
|Inputting User Weight/Difficulty selection|This was met by creating two additional pop-up windows that prompt the user to enter their weight and the difficulty they would like to be riding at. This will be tested by having the pop-up windows appear and then when the user selects their desired value it will print it out to the console to ensure it is being stored for later use in the work map.|A combo box window appears and allows the user to select their weight from a drop-down menu and saves it to the user_weight variable. Similarly, on this box, the user is able to select from another drop-down menu their desired difficulty. Both of these values were tested multiple times with different values for weight and different difficulties and were printed to the console.|Yes||

#### Latency Graphs
![image](https://github.com/Baebel43/team5capstone/blob/main/Documentation/Images/GUISystemImages/Latency%20Graphs.png)
#### Color Blind Photos Test
![image](https://github.com/Baebel43/team5capstone/blob/main/Documentation/Images/GUISystemImages/Black%20and%20White%20UI.jpg)
#### State Diagram
![image](https://github.com/Baebel43/team5capstone/blob/main/Documentation/Images/GUISystemImages/State%20Diagram.png)


### Resistance Subsystem - Caleb Rozenboom

| Item | Testing Method | Expected Results | Actual Results | Was The Constraint Fulfilled | Why Was The Constraint Not Fulfilled (if applicable) |
|------|----------------|------------------|---------|------------------------------|------------------------------------------------------|
|Connectivity|To send the force sensors (load cells) data to the Raspberry Pi, wireless comunication is required. To accomplish this, BLE was used between the slave (Arduino on the pedals) and the master (Arduino connected to the pi). Communication from Arduino to Pi proved difficult, so an extra Arduino was used. The slave broadcasts its address, where then the master can find the address and connects to it.|The expectation of this experiment is the slave communicates data correctly to the master, ultimately sending data from the sensors to the raspberrry pi in real time.|Connection was established, and the slave could send the data from the load cells over BLE to the master. As of now, the arduino is not connected to the raspberry pi, but proof of concept remains. |Partially|
|Work Map Access|To test if a work map can be uploaded and recreated using the linear actuator, a sample of work values was placed in a text file to then be extracted and converted into data for the linear actuator to move from. This is to prove that data from a trail can be collected and opened by the raspberry pi to then be recreated on the exercise bike.|The expected results of this experiment is to be able to open the work map, convert work values into actuator values, and move the actuator accordingly.|This experimentation resulted in readable data by the actuator, although did not stay within the resistance limitations for a rider to pedal (see actuator distance range constraint). The calculations from the signoff were used to convert work values into distance values for the actuator. The actuator moved in a scalable way from the work values, resulting in this constraint being fulfilled.|YES|
|Actuator Distance Range|This is a inhereted constraint from the past team. Since much of the testing on the actuator is built off of the past team's work, this same constraint is kept in place to allow a rideable trail recreation (not allowing for resistance values too high or too low for the safety of the user). The past team put into place a range of 2-25 mm between the actuator magnet and the aluminum flywheel. To test if this contraint has been fulfilled, all code sent to the actuator kept the boundary data points set by the past team.|The expected results from this experiment is to keep the actuator distance between the magnet and the flywheel between 2-25 mm.|The testing proved successful, the distance between the magnet and the flywheel stayed in the designated range; however, although this constraint is fulfilled, the range set by the past team is no longer large enough to provide all the necessary resistance values needed for a trail ride. Nevertheless, this constraint is fulfilled.|YES|
|Sensor Force Range|The load cells that were used instead of the original force sensor set a maximum force value of 200 kg (440.925 lbs). The minimum force value is still set as low as possible to provide maximum sensitivity. With load cells, the minimum force is not as much of a concern, as the output is linear to the force input. To test this constraint, the load cells were strapped to the pedal and were subject to high force during a ride under high resistance.|The expected results of this experiment is the force exerted during a ride does not exceed the maximum force set by the load cells (440.925 lbs)|The largest force value obtained from the ride on a single pedal was 174 lbs, as seen in Figure 1. This is within the maximum force range, therefore this constraint is fulfilled.|YES|
|Security|Another concern with the resistance system is the security of the load cell circuit housing enclosure strapped beneath each pedal that hold both the HX711 board, the Arduino Nano 33 BLE, and the voltage source. Each enclosure must not fall off during a ride. During the Sensor Force Range constraint experimentation, the security of the enclosure was also tested.|The expected result of this experiment is the load cell circuit housing does not fall off during a ride and not inhibit a user's experience.|The original design for the sensor circuit enclosure was designed with a different sensor in mind. Although the enclosure and straps still function as intended, the load cells require an extra layer of material (wood) below them with holes beneath each cell to ensure the middle of each cell can bend to send force data. Due to the extra layer of wood used to provide a gap for load cell, the whole pedal is top heavy, making the integrity of the load cell system compromised. Although the straps stayed in tact during the test, this is not sufficient enough to prove this constraint fulfilled, since the it did inhibit rideability.|NO|Since the extra layer of wood on top of the pedal made the system so top heavy, to combat this, a thinner layer of wood should be used with four holes drilled through to still provide each load cell with the room to bend in the middle. Additionally, the enclosure may need to be enlarged to allow the load cell circuit to sit flush with the bottom of the pedal. | 

#### Figure 1:
![image](https://github.com/Baebel43/team5capstone/assets/143441572/57c87a73-d5e2-4d52-848b-07b11d103232)

### Immersion Subsystem - Caleb Turney

| Item | Testing Method | Results | Was The Constraint Fulfilled | Why Was The Constraint Not Fulfilled (if applicable) |
|------|----------------|---------|------------------------------|------------------------------------------------------|
|Off Switch|To allow the user to turn off the fan output when riding, an off switch was implemented into the GUI of the device. This switch is a toggle that limits the output of the fans once pressed. Once the option is pressed, the send data variable that initially reads from the sensor is replaced with a 0 value so that the fans are not receiving new inputs from the bike. This remains implemented until the user presses the switch again and allows the fan to read from the sensor.|This was tested by running the program and pressing the switch multiple times during the bike's functional period. At each point in time that the switch was pressed, the fans displayed that they were receiving a value of zero and no longer outputted. This switch follows the off button constraint that was set therefore this constraint is fulfilled.|YES||
|Fan Mapping|The speed of a fan is directly proportional to the PWM duty cycle that the fan is driven with. To test this mapping constraint and ensure that the fans output was mapped to the scaled wind speed, the sensor data sent from the pi to the arduino had to be scaled. The calculated values from the signoff for speed were taken and a ratio was created between that speed and the PWM range of the fan. The 8-bit PWM range for the fan was 0-255 and the RPM range of the fan was 0-5800 . This means that for every 1 PWM there was an equivalent 22.75 RPM. The PWM was then found for each calculated RPM value in the signoff so that there was an accurate PWM value for each scaled speed value. A ratio was then found by taking each of the calculated PWM values and dividing them by the scaled speed value they were associated with. This resulted in a value of 12.3732523. This value was taken and implemented into the code so that every value that was read from the sensor would be multiplied by it.|The accuracy of this was tested by having the arduino display the speed that was read from the bike sensor and also the scaled PWM value that the fan was being driven with. The values matched those that were calculated meaning that the fan mapping constraint was fulfilled.|YES|
|Fan Control|The fan control constraint was tested by running both the bike code and the arduino fan code at the same time. If the speed of the fans changed when the sent value of the bike speed changed, it meant that the fans were being properly controlled and adapting to new inputs.|Whenever the user increased or decreased the speed, a new value was sent to the fans which resulted in visible and audible change in speed. This shows that the fans are indeed adjustable therefore this constraint is fulfilled.|YES|
|Output Noise Level|An app on the phone was used to test the output noise level of the fan. The fan was run at different speeds while the phone was held approximately 4 feet away.|The max decibels that were read was around 65-66 dBA. This was tested at multiple different speeds to give a wide range of different sound output levels. This falls slightly outside the range set in this constraint but is within an acceptable margin for safe testing. Due to how close this value is to the constraint set it will not be considered fulfilled.|NO|Setting different PWM frequencies on the fan can have an effect on the noise level that the fan outputs. More research and testing on this frequency may result in a value that allows the fans to fall within a more acceptable sound level range.
|Power|To test the power draw of the fan, the fan was connected to both the wall wart power supply and an adjustable bench power supply in the lab. A multimeter was connected so that both the voltage and the current draw of the fan could be measured.|When the fan was run at full power, the voltage reading was approximately 11.3 and the current draw was 1.67. The adjustable power supply was used to confirm that the readings were not the result of a lack of power from the chosen wall wart power supply. This shows that the fan only used around 18.871 Watts of power. The wall wart is rated to supply 60 Watts of power therefore it was reasonably inferred that the 28.8 watts of power outlined in the constraint were achievable. However, due to the fans not drawing that much power it cannot be said with 100% certainty that this is true. This constraint is considered fulfilled.|YES|

### Work Subsystem - Jayden Marcom

| Item | Testing Method | Results | Was The Constraint Fulfilled | Why Was The Constraint Not Fulfilled (if applicable) |
|------|----------------|---------|------------------------------|-----------------------------------------------------|
|Recording elevation and distance| We tested this by using a known elevation and using google maps to measure distance in miles to three decimal places then using these values to compare to the measured on the subsystem. This same distance was measured using the bike and subsystem 5 times.|The measured values at worst were 0.00123 miles off of the measured distance. This value is only one rotation of the wheel more than the intended value and was only recorded once during the 5 attempts. The elevation was at worst 0.3 meters off the measured value.|YES||
|Work Calculation|he original proposed way to measure this was using CAD software, however the same measurement was later proposed to be measured using an apple watch and comparing it to the calculated. We used the apple watch app to calculate joules expended and compared it to the value determined by the subsystem|To do this team 5 had two individuals who both had relatively similar weights (150lbs and 155lbs) do multiple runs of the same recording using an apple watch. The main results for the users were from the range 32 Kilojoules with minimal pedaling to 51 kilojoules with maximum pedaling. With the average being 42.5 Kilojoules. When comparing this to the work value from the subsystem which was measured to be 47 Kilojoules. *See the graph below |YES,This result provides a work calculation that is comparable to the original work from the actual trail.||
|Distance between the box attached to the bike frame and the spoke|This constraint was checked by measuring the depth of the 3d printed frame. |This value was .55 inch or 13.97mm.|Yes||
|The magnetic sensor can be no more than 23.75 mm away from the magnet and it can be no closer than 12.7 mm.|This constraint was checked by attaching the box to the frame of the bike and measuring the distance to the magnet. The box was attached at the halfway point of the wheel’s radius. *The 3d printed holder was snapped before this test was able to be performed so the thickness of the holder is added during the calculations.|See the graph following this section for datapoints. There is a single bike that was tested that provided a value below the 12.7mm|No|The bike that provided a value below 12.7mm was a BMX bike that did not contain any gears and had a tight set of back frame arms.|
|Splash Resistance|This constraint was not tested as the splash proofing of the actual case was not done.|The solutions provided in the signoff if used meet all requirements of the constraint.|n/a||
|Sensing Speed (Minimum and Maximum Velocity of 190mph)|This was tested by riding the bike downhill as fast as we safely could using three different people 3 times each. We recorded the speed using the navigation app Waze.|The highest speed we were able to achieve on the bike was 32 MPH. The subsystem was able to detect the magnet in front of the sensor 4 times per rotation at this speed. This result would provide evidence that greater speeds can be achieved and detected.|NO|Testing done at the speeds proposed were not able to be achieved effectively and safely.|

#### Figure 2:
![image](https://github.com/Baebel43/team5capstone/blob/main/Documentation/Images/WorkSystemImages/Amount_of_detects_graph.png)
#### Figure 3:
![image](https://github.com/Baebel43/team5capstone/blob/main/Documentation/Images/WorkSystemImages/Amount_of_detects_graph.png)
#### Figure 4:
![image](https://github.com/Baebel43/team5capstone/blob/main/Documentation/Images/WorkSystemImages/Measured_work_Graph.png)

### Audio Subsystem - Jesse Brewster

| Item | Testing Method | Results | Was The Constraint Fulfilled | Why Was The Constraint Not Fulfilled (if applicable) |
|------|----------------|---------|------------------------------|------------------------------------------------------|
|Recording Audio without Undesired Noises|The Blue Snowball microphone has a cardioid polar pattern meaning it accepts audio from one direction in a 180° pattern which reduces the audio pick up from the user and bike noises. The included mic-filter reduces wind noise when the bike is moving forward. To test this, the microphone was attached to the bike and the audio was recorded while the bike was enroute using the Python Microphone_record.py code. |There was no wind noise recorded, therefore the filter greatly reduced the wind noise if any. However there was some bike and user noises. But these were able to be partially filtered out with a high-pass and low pass filters specified at certain frequencies. The software used was Ableton Live 11. When the audio file was put in, there were unwanted frequencies at approximately 80Hz and 7kHz so a high-pass and low-pass filter was applied to decrease these frequencies and boost the desirable frequencies.|Partially. Some noises remained in the recording but most were able to be filtered out using Ableton.|
|Processing Audio|The audio was uploaded to a Google Drive using the Raspberry Pi for storage of the file. The file was then processed with a Python code to add a filter and divide the audio into segments for looping playback.|Each audio file recorded was sent to the Drive successfully through the Raspberry Pi. The processing occurred on a separate computer and it successfully divided the audio file into many other audio files for playback. These audio files were played back using a python code in accordance to the work value given from the Work and Resistance systems. |YES|
|Syncing Audio with Work Map|The playback code within Python accepts a work value and it playbacks the corresponding audio file that syncs it with the work value of the trail progression. There is a certain range of input ‘work’ values that correspond to one of the audio files and it continues to play and loop that audio file until a value outside of that range is given. Then it transitions to the next audio file where it ccontinues the process until the biker has progressed through the entirety of the trail.|Once the biker has progressed past 1700 Joules and has received this input from the Work Subsystem, then the Python code will switch to play the second audio clip and continuously play it until they have reached 3000 Joules of work done. With a trail audio of 3 minutes, the audio will be divided into 6 - 30 second audio clips. By using this method, the audio was successfully synced to the Work map and the audio made quick transitions to the next section as the work value increased.|YES|
|Correct Python Libraries Used|The libraries used were pyaudio, wave, datetime, os, math. These are found within the Playback.py code, the Test_2.py code, and the Microphone_record.py code. These libraries were all used for the recording, the processing, and the playback of the audio.|These libraries were tested by successfully running the codes on a separate computer and dividing the audio file into many other sectioned audio files. The machine learning software originally intended to separate audio by frequency was unable to function due to incompatibility issues with the Raspberry Pi. Team 5 opted to divide the trail audio into time segments of 30 second audio clips. |YES|
|Limit Audio level output to speaker|Multiple trail audio’s were played through the speakers that are driven by the Raspberry Pi. Team 5 used a SPL meter to measure gain from around 25 inches from the speakers. This is the approximate distance that the user will be from the speakers when riding. There were multiple tests recorded from different audio files.|After 10 tests, the maximum decibel output was 78.2 dB at that distance, meaning we stayed below the 80 decibel requirement, thus reducing hearing fatigue. This also complies with the OSHA Law that states that in a public environment, audio must be played at less than 85 decibels for 8 hours.|YES|
|Audio Wavelengths of Recording Should Match Playback|To compare the two audio files and their wavelengths, the spectrograms of both audio files was generated in Matlab which shows the frequency and wavelengths of the audio file over time. This audio was played through the speakers that were connected to the Raspberry Pi and a microphone was placed in front of the speakers and a new audio was recorded. Then, the two spectrograms were compared and a series of measurements were made.|The following are the results: Root Mean Square Error (RMSE): 0.2146, Mean Absolute Error (MAE): 0.1579, Structural Similarity Index (SSIM): 0.0579. The RMSE value measures the average difference between the two audio files and their frequencies. With this value being less than even 0.3, then it proves that the output audio wavelengths coming from the speaker match that of the raw recorded audio. The spectrograms matched patterns and frequencies over time thus correlating to the relatively the same wavelengths.|YES|

#### Figure 5:
![image](https://github.com/Baebel43/team5capstone/blob/main/Documentation/Images/AudioAndVideoSystemImages/Spectrogram%20of%20Audio%20File.png)

#### Figure 6:
![image](https://github.com/Baebel43/team5capstone/blob/main/Documentation/Images/AudioAndVideoSystemImages/Speaker_Output_Gain_Graph.png)

### Video Subsystem - Utsav Singha

| Item | Testing Method | Results | Was The Constraint Fulfilled | Why Was The Constraint Not Fulfilled (if applicable) |
|------|----------------|---------|------------------------------|------------------------------------------------------|
|Minimum Recording FPS|The team viewed each recording file to verify it was at the specified minimum FPS of 60|The video recordings were always at the minimum FPS requirement.|YES|
|Minimum Resolution|The team recorded the video at the resolution of 1080p, then replayed it on the bike through the RaspberryPi, and checked for video stability.|Due to the low RAM space on the RaspberryPi, 1080p would cause visual tear, distortions, and overall lag. The team then adjusted the video output on the RaspberryPi and tried replaying at 720p, and although the result was slightly better, the issues from the previous test persisted. After dropping the resolution to 480p the video was finaly stable and was replayable smoothly.|NO|The RaspberryPi could not sustain video resolutions above 480p without major visual tear and distortion.|
|Minimum User Speed|The team hard set the video replay on the RaspberryPi to replay the video at 25% speed, and checked the display to make sure the video was replaying smoothly with no breakage or stuttering. The team would also take this time to ensure the video was interpolated with no issues or distortions from the interpolation process|The video was stable and smooth while replayed at 25% of the original rider's speed. The interpolation software worked with no issues.|YES|
|Storage Space Requirements|The team took a 4 hour long ride and interpolated the video recorded before compressing said video to ensure it was within the 216GB max storage space requirement|Initially a 4 hour 720p video was used, but after interpolation, the video was going to be well over 2 terabytes and would not even fit on the drive of the PC used to run FlowFrames. Since the RaspberryPi also could not run 720p videos, the team decided to drop the video resolution to 420p. Next, a 4 hour 420p 60 FPS video was used to ensure it would fit on the drive, however this too was over 1 terabyte. After running a 2 hour 420p 60 FPS video through the system, the video took up exactly 215.5 gigabytes of storage, which now fits within the constraint.|NO|4 hours of video was not feasable due to the interpolated videos being almost 1 terabyte of space. After testing, the max video length at 420p is 2 hours.|

