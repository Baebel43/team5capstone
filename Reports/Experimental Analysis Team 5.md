# Team 5 - Ride Replay Kit
## Team Members: Benjamin Ebel, Caleb Rozenboom, Caleb Turney, Jayden Marcom, Jesse Brewster, Utsav Singha

## Experimentation

### GUI Subsystem - Benjamin Ebel

| Item | Testing Method |Expected Results | Actual Results | Was The Constraint Fulfilled |
|------|----------------|------------------|----------------|------------------------------|
|Overexertion Reminder|Using the time library in Python we can see how long a piece of code or function has been running. Using this a variable was created for detecting how long the user has been riding and at the 2-hour mark a pop-up window appears pausing the trail and alerting the user that they have been riding for over 2 hours. The message box then asks them to acknowledge that if they continue to ride it could possibly cause damage to their muscles. After the trail has been started a time variable starts counting up in seconds and once it gets to 7200 seconds the pop-up window appears alerting the user and won’t continue until they press ok on the window. To test this I will set the time variable to 7140 seconds to allow replay for a minute and then at the minute mark the pop-up window will appear. I will then press the button to attempt to bypass the window. I will then pedal the bike to attempt to bypass the window.|I expect that for this test user will ride for the minute and at the end of the minute a message box will appear on the screen asking them to acknowledge that they have been riding for 2 hours and it will not allow them to continue riding until the ok button on the message box is clicked.|The pop-up window then appeared alerting the user of the risk of overexertion. Attempting to press the main UI will only cause the screen to blink twice and not allow any interactions. Attempting to pedal does not unpause the trail and the message remains on the screen. The only way to continue the trail video is to press the ok button on the pop-up menu.|Yes|
|Loading Screen/Interaction Latency/User Interrupt|Using the time library in Python we can see how long a piece of code or function has been running. I set a start time variable to start at the beginning of a function call and an end time variable to store the value of the time at the end of the function call. Once this had been done I took the end time minus the start time to get the result of how long the function took to run. If one of these tests takes longer than 300ms to run a loading screen was put in place to alert the user that their input has been seen and will be handled soon.|I expect that all functions will be under the 300ms execution time and the system will not need to add a loading screen to any interactions.|Almost every function in the GUI had less than 300ms execution time except for loading the video. I tested the play video function with a short video of around 5 minutes and a 4-hour-long trail ride and both of these tests resulted in a latency of longer than a second. Since this is longer than the allowed latency of 300ms I put in a loading screen to ensure the user was aware their input had been seen. These test latencies can be seen under the Latency Graph header below.|Yes|
|Color Blindness Sensitivity|I will take a picture of the GUI using an iPhone camera. Then I will edit a black-and-white filter over it using the built-in filters on the iPhone. This will ensure that everything on the GUI can still be read by users with the harshest kind of color blindness which is total color blindness.|Since the GUI is already grey and black I believe that there will be no issue with any color-blind person using the GUI.|Using the photos below under the Color Blind Photos Test header, it can be seen that the UI would still be visible to someone who had complete color blindness.|Yes|
|Menu Interaction to Desired State|The goal of this constraint was to ensure the User does not get confused or frustrated while navigating through the menu. To eliminate this the GUI was simplified to have all the menu options be presented to the user on one page. This ensures that the user does not have to go through multiple different windows to achieve the desired result. To test this all menu interactions will be interacted with and placed into a state diagram to display all the possible menu interactions and their functions.|Since I designed the GUI to be straightforward for ease of use I believe there will be no issue in the user being confused or frustrated with the number of interactions it takes to get to their desired result. |Since all the buttons on the GUI are only set to do a specific task all of the buttons achieve their task and then return to the main menu waiting for the next user interaction. All the menu interactions were plotted in the state diagram in the State Diagram header below.|Yes|
|Inputting User Weight/Difficulty selection|This was met by creating two additional pop-up windows that prompt the user to enter their weight and the difficulty they would like to be riding at. This will be tested by having the pop-up windows appear and then when the user selects their desired value it will print it out to the console to ensure it is being stored for later use in the work map.|I expect that the variable will be stored in the Python script under the desired variables and will be able to be seen in the console proving they have executed correctly|A combo box window appears and allows the user to select their weight from a drop-down menu and saves it to the user_weight variable. Similarly, on this box, the user is able to select from another drop-down menu their desired difficulty. Both of these values were tested multiple times with different values for weight and different difficulties and were in fact printed to the console.|Yes|

#### Latency Graphs
![image](https://github.com/Baebel43/team5capstone/blob/main/Documentation/Images/GUISystemImages/Latency%20Graphs.png)
#### Color Blind Photos Test
![image](https://github.com/Baebel43/team5capstone/blob/main/Documentation/Images/GUISystemImages/Black%20and%20White%20UI.jpg)
#### State Diagram
![image](https://github.com/Baebel43/team5capstone/blob/main/Documentation/Images/GUISystemImages/State%20Diagram.png)


### Resistance Subsystem - Caleb Rozenboom

| Item | Testing Method | Expected Results | Actual Results | Interpretation |
|------|----------------|------------------|----------------|----------------|
| Connectivity | To send the force sensors (load cells) data to the Raspberry Pi, wireless comunication is required. To accomplish this, BLE was used between the slave (Arduino on the pedals) and the master (Arduino connected to the pi). Communication from Arduino to Pi proved difficult, so an extra Arduino was used. The slave broadcasts its address, where then the master can find the address and connects to it. To test the reliability of the connection, ten connections were run and timed to ensure reliable connection from pedal data to raspberry pi. The graph of each run and its corresponding time to connect is pictured below. | The expectation of this experiment is the slave communicates data correctly to the master, ultimately sending data from the sensors to the raspberrry pi in real time. | Connection was established, and the slave could send the data from the load cells over BLE to the master. | The results were as expected, connection could be established between the slave and master arduino, and the time to connect is reasonable. Therefore, this constraint is fulfilled.| 
| Work Map Access | To test if a work map can be uploaded and recreated using the linear actuator, a sample of work values was placed in a text file to then be extracted and converted into data for the linear actuator to move from. This is to prove that data from a trail can be collected and opened by the raspberry pi to then be recreated on the exercise bike. | The expected results of this experiment is to be able to open the work map, convert work values into actuator values, and move the actuator accordingly. | This experimentation resulted in readable data by the actuator, although did not stay within the resistance limitations for a rider to pedal (see actuator distance range constraint). The calculations from the signoff were used to convert work values into distance values for the actuator. The actuator moved in a scalable way from the work values. | The results were as expected, as readable data was sent to the actuator from a work map. Therefore, this constraint is fulfilled |
| Actuator Distance Range | This is a inhereted constraint from the past team. Since much of the testing on the actuator is built off of the past team's work, this same constraint is kept in place to allow a rideable trail recreation (not allowing for resistance values too high or too low for the safety of the user). The past team put into place a range of 2-25 mm between the actuator magnet and the aluminum flywheel. To test if this contraint has been fulfilled, all data sent to the actuator retained the boundary data points in sotware. A ruler was then used to measure the distance during the run of test values to validate. | The expected results from this experiment is to keep the actuator distance between the magnet and the flywheel between 2-25 mm. | The testing proved successful, the distance between the magnet and the flywheel stayed in the designated range of 2-25 mm. A plot of the results is shown below. | The results were as expected, since the range of 2-25 mm could be set. However, this range is not wide enough to account for all the work values in the work map. As a result, this constraint is no longer necessary, and a new range likely needs to be established to provide enough range for a trail ride playback. Nevertheless, the actuator distance range can be set, therefore, this constraint is fullfilled. |
| Sensor Force Range | The load cells that were used instead of the original force sensor set a maximum force value of 200 kg (440.925 lbs). The minimum force value is still set as low as possible to provide maximum sensitivity. With load cells, the minimum force is not as much of a concern, as the output is linear to the force input. To test this constraint, the load cells were strapped to the pedal and were subject to high force (rider weighing 170 lbs) during a ride under high resistance. | The expected results of this experiment are that the force exerted during a ride does not exceed the maximum force set by the load cells (440.925 lbs). | The largest force value obtained from the ride on a single pedal was 174 lbs, as seen in the graph below. This is well within the maximum force range of 440.925 lbs, meaning the load cells are never compromised | Since the largest force value obtained did not exceed the stated maximum force, this constraint is fulfilled. |
| Security | Another concern with the resistance system is the security of the load cell circuit housing enclosure strapped beneath each pedal that hold both the HX711 board, the Arduino Nano 33 BLE, and the voltage source (three double A batteries). To test the security, during the Sensor Force Range constraint experimentation, the security of the enclosure was also tested. | The expected result of this experiment is the load cell circuit housing does not fall off during a ride and not inhibit a user's experience. | The result from this experiment was that the enclosure was too top heavy, contributing to a greater inhibation of rideability. | The original design for the sensor circuit enclosure was designed with a different sensor in mind. Although the enclosure and straps still function as intended, the load cells require an extra layer of material (wood) below them with holes beneath each cell to ensure the middle of each cell can bend to send force data. The thickness needs to be greatly reduced to minimize weight on the top of the pedal. Although the straps stayed in tact during the test, due to the inhibition of rideability, this is not sufficient enough to prove this constraint fulfilled. | 

#### Connectivity Time Graph
![image](https://github.com/Baebel43/team5capstone/assets/143441572/58feac18-9aab-4526-97f1-61c0e9799f83)
#### Actuator Distance Graph
![image](https://github.com/Baebel43/team5capstone/assets/143441572/9059014b-6e51-44e1-936d-2f4bb2a9ecbf)
#### Force Sensor Graph
![image](https://github.com/Baebel43/team5capstone/assets/143441572/57c87a73-d5e2-4d52-848b-07b11d103232)

### Immersion Subsystem - Caleb Turney

| Item | Testing Method | Expected Results | Actual Results | Interpretation |
|------|----------------|---------|------------------------------|------------------------------------------------------|
|Off Switch|To allow the user to turn off the fan output when riding, an off switch was implemented into the GUI of the device. This switch is a toggle that limits the output of the fans once pressed. Once the option is pressed, the send data variable that initially reads from the sensor is replaced with a 0 value so that the fans are not receiving new inputs from the bike. This remains implemented until the user presses the switch again and allows the fan to read from the sensor.|The expectation for this constraint is that when button on the GUI is pressed, the fans will no longer spin or react to the users input on the bike. Then once the button is pressed again input is accepted|This was tested by running the program and pressing the switch multiple times during the bike's functional period. At each point in time that the switch was pressed, the fans displayed that they were receiving a value of zero and no longer outputted. This switch follows the off button constraint that was set therefore this constraint is fulfilled.|The button worked as intended, and provided a very quick response when turning the fans on and off. So no only was the constraint met but it was efficient well functioning|
|Fan Mapping|The speed of a fan is directly proportional to the PWM duty cycle that the fan is driven with. To test this mapping constraint and ensure that the fans output was mapped to the scaled wind speed, the sensor data sent from the pi to the arduino had to be scaled. The calculated values from the signoff for speed were taken and a ratio was created between that speed and the PWM range of the fan. The 8-bit PWM range for the fan was 0-255 and the RPM range of the fan was 0-5800 . This means that for every 1 PWM there was an equivalent 22.75 RPM. The PWM was then found for each calculated RPM value in the signoff so that there was an accurate PWM value for each scaled speed value. A ratio was then found by taking each of the calculated PWM values and dividing them by the scaled speed value they were associated with. This resulted in a value of 12.3732523. This value was taken and implemented into the code so that every value that was read from the sensor would be multiplied by it.|The expectation for this constraint was that the arduino controlling the fans would be able to read the incoming value from the bike and then respond with a proper PWM value that would result in a fan speed that was indicative of wind speed. The arduino serial monitor should show the current values from the bike and the mapped values as well. |The accuracy of this was tested by having the arduino display the speed that was read from the bike sensor and also the scaled PWM value that the fan was being driven with. The values matched those that were calculated meaning that the fan mapping constraint was fulfilled.|The values were properly mapped and matched the table of values that was calculated in the signoff. Although we did not have the means to directly measure the wind speed being outputted from the fan, the numerical data that we were receiving indicated success|
|Fan Control|The fan control constraint was tested by running both the bike code and the arduino fan code at the same time. If the speed of the fans changed when the sent value of the bike speed changed, it meant that the fans were being properly controlled and adapting to new inputs.|The expected result of this constraint was for the fans to increase in speed whenever the user increased their speed on the bike. We should not only be able to feel the change in speed of the fans but also here an audible change as well since the fans were loud.|Whenever the user increased or decreased the speed, a new value was sent to the fans which resulted in visible and audible change in speed. This shows that the fans are indeed adjustable therefore this constraint is fulfilled.|Due to the fans changing speeds whenever the user would change speeds, it was confirmed that there was at least some of level of control being exerted on the fans by the bike. And because the fans were not outputting at a constant speed at all times it showed that they could be controlled and not just have static values|
|Output Noise Level|An app on the phone was used to test the output noise level of the fan. The fan was run at different speeds while the phone was held approximately 4 feet away.|The expectation for this constraint was that no matter what speed the fans were outputting, they would stay within the appropriate decibel range.|The max decibels that were read was around 65-66 dBA. This was tested at multiple different speeds to give a wide range of different sound output levels. This falls slightly outside the range set in this constraint but is within an acceptable margin for safe testing. Due to how close this value is to the constraint set it will not be considered fulfilled.|Although the datasheet for the fans said that the max decibels that the fan would output was around 59 dB, it was found that there were other factors that could affect the noise level of the fans. Much to our surprise, setting different PWM frequencies on the fan can have an effect on the noise level that the fan outputs. More research and testing on this frequency may result in a value that allows the fans to fall within a more acceptable sound level range.|
|Power|To test the power draw of the fan, the fan was connected to both the wall wart power supply and an adjustable bench power supply in the lab. A multimeter was connected so that both the voltage and the current draw of the fan could be measured.|The expectation of this constraint was that the fan would always be provided enough power no matter what speed it was running at. Even at max power draw, there should not be any indication that power ssupplies output was being capped and providing insuficient power to the fan|When the fan was run at full power, the voltage reading was approximately 11.3 and the current draw was 1.67. The adjustable power supply was used to confirm that the readings were not the result of a lack of power from the chosen wall wart power supply. This shows that the fan only used around 18.871 Watts of power.|The wall wart is rated to supply 60 Watts of power therefore it was reasonably inferred that the 28.8 watts of power outlined in the constraint were achievable. However, due to the fans not drawing that much power it cannot be said with 100% certainty that this is true. This constraint is considered fulfilled.|

### Work Subsystem - Jayden Marcom

| Item | Testing Method | Expected Results | Actual Results | Interpretation |
|------|----------------|---------|------------------------------|-----------------------------------------------------|
|Recording elevation and distance| We tested this by using a known elevation and using google maps to measure distance in miles to three decimal places then using these values to compare to the measured on the subsystem. This same distance was measured using the bike and subsystem 5 times.|The expected result is that the measured value is exactly the same as the distance from the google maps|The measured values at worst were 0.00123 miles off of the measured distance.| This value is only one rotation of the wheel more than the intended value and was only recorded once during the 5 attempts. The elevation was at worst 0.3 meters off the measured value.|
|Work Calculation|he original proposed way to measure this was using CAD software, however the same measurement was later proposed to be measured using an apple watch and comparing it to the calculated. We used the apple watch app to calculate joules expended and compared it to the value determined by the subsystem|To do this team 5 had two individuals who both had relatively similar weights (150lbs and 155lbs) do multiple runs of the same recording using an apple watch. The main results for the users were from the range 32 Kilojoules with minimal pedaling to 51 kilojoules with maximum pedaling. With the average being 42.5 Kilojoules. When comparing this to the work value from the subsystem which was measured to be 47 Kilojoules. *See the graph below |The result from the subsystem should be comparable to the average of the work measured during the test with the apple watch.|This result provides a work calculation that is 4.5 Kilojoules greater than the average work from the actual trail. This result is comparable.|
|Distance between the box attached to the bike frame and the spoke(This constraint is less relevant due to the next constraint being more percise and applies to all bikes)|This was expected to be 20mm|This constraint was checked by measuring the depth of the 3d printed frame. |This value was .75 inch or 19.05mm.|The measured value was well within the expected |
|The magnetic sensor can be no more than 23.75 mm away from the magnet and it can be no closer than 12.7 mm.|This constraint was checked by attaching the box to the frame of the bike and measuring the distance to the magnet. The box was attached at the halfway point of the wheel’s radius. *The 3d printed holder was snapped before this test was able to be performed so the thickness of the holder is added during the calculations.|These values are expected to be lower than 23.75 mm for all bikes and greater than 12.7 mm.|See the graph following this section for datapoints. There is a single bike that was tested that provided a value below the 12.7mm|The bike that provided a value below 12.7mm was a BMX bike that did not contain any gears and had a tight set of back frame arms.|
|Splash Resistance|This constraint was not tested as the splash proofing of the actual case was not done.|The case should be water resistant and should not allow water to directly touch the internal devices|The solutions provided in the signoff if used meet all requirements of the constraint.|
|Sensing Speed|This was tested by riding the bike downhill as fast as we safely could using three different people 3 times each. We recorded the speed using the navigation app Waze.|Maximum Velocity of 190mph|The highest speed we were able to achieve on the bike was 32 MPH. The subsystem was able to detect the magnet in front of the sensor 4 times per rotation at this speed. This result would provide evidence that greater speeds can be achieved and detected.|Testing done at the speeds proposed were not able to be achieved effectively and safely. At the rate that the numbers seem to be going a value around 100mph will be our true maximum|

#### Figure 2:
![image](https://github.com/Baebel43/team5capstone/blob/main/Documentation/Images/WorkSystemImages/Amount_of_detects_graph.png)
#### Figure 3:
![image](https://github.com/Baebel43/team5capstone/blob/main/Documentation/Images/WorkSystemImages/Distance_of_Mag_graph.png)
#### Figure 4:
![image](https://github.com/Baebel43/team5capstone/blob/main/Documentation/Images/WorkSystemImages/Measured_work_Graph.png)


### Audio Subsystem - Jesse Brewster

| Item | Testing Method | Expected Results | Actual Results | Interpretation |
|------|----------------|---------|------------------------------|------------------------------------------------------|
|Recording Audio without Undesired Noises|The Blue Snowball microphone has a cardioid polar pattern meaning it accepts audio from one direction in a 180° pattern which reduces the audio pick up from the user and bike noises. The included mic-filter was added to reduce wind noise when the bike is moving forward. To test this, the microphone was attached to the front of the bike and the audio was recorded while the bike was enroute using a python code.|Team 5 wanted to record only the desirable trail sounds such as environmental noises. This includes recording no wind noise and mitigating any bike wheel noises or user noises from riding on the trail. | There was no wind noise recorded, therefore the mic filter greatly reduced the wind noise if any. However there were still some bike and user noises that remained in the recording, meaning the constraint was not fully met.|This constraint was not fully met due to only filtering out wind noises but not filtering out human voices or bike wheel noises. A solution to this is, to use AI to remove voices or noises from the recording. An example of a 1 minute recording from the bike trail was loaded into the AI website lalal.ai, where the software removed almost all the voices from the recording and mitigated the bike noises. This software offers only 1 minute for free and costs money for a certain amount of minutes of recording. Another solution to remove noises is to put the audio files into the software, Ableton Live 11. Within this software, these extraneous noises were partially filtered out with high-pass and low pass filters specified at frequencies of approximately 80Hz and 7kHz.|
|Processing Audio|The audio was uploaded to a Google Drive folder using the Raspberry Pi for storage of the file. The file was then processed with Ableton Live to add any filters, and a Python code was used to divide the audio into segments of smaller audio files for audio playback.| The audio file can be uploaded to the Google Drive and the file can be downloaded onto another computer for processing and editing of the trail audio. |Each audio file recorded was sent to the Drive successfully through the Raspberry Pi. The free version of Google Drive allows for 15 GB of free storage space, so as long as the file is less than that it can be uploaded. The longest audio file we intend to process would be 4 hours, and this would be a total file size of 240 MB, which means there is plenty of room for multiple trail recordings to be uploaded to this Google Drive. The files were downloaded by an external computer where processing occurred and it successfully divided the audio file into many other audio files for playback. These audio files were played back using a python code in accordance to the work value given from the Work and Resistance systems.|The constraint was met and the files were able to be accessed through the Drive. A way to improve this would to automate the file upload and download process as well as the filtering.|
|Syncing Audio with Work Map|A python code takes the original audio file and divides the audio into 30 second sections and creates audio files for each one of these sections. The playback code within Python accepts a work value and it plays back the corresponding audio file that syncs it with the work value of the trail progression. There is a certain range of input ‘work’ values that correspond to one of the audio files and it continues to play and loop that audio file until a value outside of that range is given. Then it transitions to the next audio file where it continues the process until the biker has progressed through the entirety of the trail.|The audio should sync with the work map by accepting work values from the work subsystem and playing back the correct audio file that corresponds to the progression in the trail.|Once the biker has progressed past 1700 Joules and has received this input from the Work Subsystem, then the Python code will switch to play the second audio clip and continuously play it until they have reached 2500 Joules of work done. With a trail audio of 3 minutes, the audio will be divided into 6 - 30 second audio clips. By using this method, the audio was successfully synced to the Work map and the audio made quick transitions to the next section as the work value increased.|The constraint was met because the audio actively changed depending on the continual input of work values. There maybe some slight choppiness if the audio file were to transition in the middle of playing a unique sound.|
|Correct Python Libraries Used|The libraries used were pyaudio, wave, datetime, os, math. These are found within the Playback.py code, the Test_2.py code, and the Microphone_record.py code. These libraries were all used for the recording, the processing, and the playback of the audio.|The Python libraries necessary for these audio processing codes to work should be used and should run without error.|These libraries were tested by successfully running the codes on a separate computer and dividing the audio file into many other sectioned audio files. The machine learning software originally intended to separate audio by frequency was unable to function due to incompatibility issues with the Raspberry Pi. Team 5 opted to divide the trail audio into time segments of 30 second audio clips. |This constraint was met because the correct libraries necessary for the code to run in Python were chosen and the code operated as desired.|
|Limit Audio level output to speaker|Multiple trail audio’s were played through the speakers that are driven by the Raspberry Pi. The Logitech speakers were turned all the way up to maximum volume. Team 5 used a SPL meter to measure gain from around 25 inches from the speakers. This is the approximate distance that the user will be from the speakers when riding. There were multiple tests recorded from different audio files of trail recordings.|The audio playback volume should not exceed 80 dB's whenever the user is biking the trail.|After 10 tests, the maximum decibel output was 78.2 dB at a distance of 25 inches, meaning we stayed below the 80 decibel requirement, thus reducing hearing fatigue. This also complies with the OSHA Law that states that in a public environment, audio must be played at less than 85 decibels for 8 hours.|The constraint was met and the audio stayed below the maximum required volume output of the speakers.|
|Audio Wavelengths of Recording Should Match Playback|To compare the two audio files and their wavelengths, the spectrograms of both audio files was generated in Matlab which shows the frequency and wavelengths of the audio file over time. This audio was played through the speakers that were connected to the Raspberry Pi and a microphone was placed in front of the speakers and a new audio was recorded. Then, the two spectrograms were compared and a series of measurements were made.|The wavelengths and frequencies of the audio file were replicated in playback in comparision to the original recording, effectively replicating the trail audio experience. |The following are the results: Root Mean Square Error (RMSE): 0.2146, Mean Absolute Error (MAE): 0.1579, Structural Similarity Index (SSIM): 0.0579. The RMSE value measures the average difference between the two audio files and their frequencies. With this value being less than even 0.3 dB, then it proves that the output audio wavelengths coming from the speaker match that of the raw recorded audio. The spectrograms matched patterns and frequencies over time thus correlating to the relatively the same wavelengths.|This constraint was met because the audio from the recording matched similarly to that of the audio that was played back after processing and playback has occured.|

#### Figure 5:
![image](https://github.com/Baebel43/team5capstone/blob/main/Documentation/Images/AudioAndVideoSystemImages/Matlab_spectrogram_comparision.png)

#### Figure 6:
![image](https://github.com/Baebel43/team5capstone/blob/main/Documentation/Images/AudioAndVideoSystemImages/Speaker_Output_Gain_Graph.png)

### Video Subsystem - Utsav Singha

| Item | Testing Method | Expected Results | Actual Results | Was The Constraint Fulfilled |
|------|----------------|------------------|---------|------------------------------|
|Minimum Recording FPS|The team checked each recording file to verify it was recorded at the specified minimum FPS of 60.|The initial recorded videos would be at 60 FPS minimum.|The video recordings were always at the minimum FPS requirement.|YES, there were no differences between the expected outcome and the actual results.|
|Minimum Resolution|The team recorded the video at the resolution of 1080p, then replayed it on the bike through the RaspberryPi, and checked for video stability.|The expectation for the RaspberryPi was for it to be able to handle 1080p videos, so therefore the video output looks good on the monitor.|Due to the low RAM space on the RaspberryPi, 1080p would cause visual tear, distortions, and overall lag. The team then adjusted the video output on the RaspberryPi and tried replaying at 720p, and although the result was slightly better, the issues from the previous test persisted. After dropping the resolution to 480p the video was finaly stable and was replayable smoothly.|NO, the RaspberryPi could not sustain video resolutions above 480p without major visual tear and distortion.|
|Minimum User Speed|The team recorded a video of a stopwatch from 0 seconds to 1 second at two decimal places at 60FPS, then replayed the video recording on the monitor and rerecorded the video output. After analyzing the  rerecorded video, there was an output of 30 distinct number values, which results in 30FPS playback.|It was expected that the video replay was smooth (replayed at 30FPS)|The video was stable and smooth.|YES, there were differences between the expected outcome and the actual outcome.|
|Storage Space Requirements|The team took a 4 hour long ride and interpolated the video recorded before compressing said video to ensure it was within the 216GB max storage space requirement.|It was expected that after interpolation, the 4 hour video would fit within 216GB as to not take up too much storage space, and so that it would be possible to fit multiple rides within a storage drive.|Initially a 4 hour 720p video was used, but after interpolation, the video was going to be well over 2 terabytes and would not even fit on the drive of the PC used to run FlowFrames. Since the RaspberryPi also could not run 720p videos, the team decided to drop the video resolution to 480p. Next, a 4 hour 480p 60 FPS video was used to ensure it would fit on the drive, however this too was over 1 terabyte. After running a 2 hour 480p 60 FPS video through the system, the video took up exactly 215.5 gigabytes of storage, which now fits within the constraint.|NO, 4 hours of video was not feasable due to the interpolated videos being almost 1 terabyte of space. After testing, the max video length at 480p is 2 hours.|

